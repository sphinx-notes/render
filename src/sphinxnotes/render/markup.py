"""
sphinxnotes.markup
~~~~~~~~~~~~~~~~~~

Rendering markup text to doctree nodes.

:copyright: Copyright 2025 by the Shengyu Zhang.
:license: BSD, see LICENSE for details.
"""

from dataclasses import dataclass
from typing import TYPE_CHECKING

from docutils import nodes
from docutils.parsers.rst.states import Struct
from docutils.utils import new_document
from sphinx import version_info
from sphinx.util.docutils import SphinxDirective, SphinxRole
from sphinx.transforms import SphinxTransform
from sphinx.environment.collectors.asset import ImageCollector

from .render import Host

if TYPE_CHECKING:
    from docutils.nodes import Node, system_message


@dataclass
class MarkupRenderer:
    host: Host

    def render(
        self, text: str, inline: bool = False
    ) -> tuple[list[Node], list[system_message]]:
        if inline:
            return self._render_inline(text)
        else:
            return self._render(text), []

    def _render(self, text: str) -> list[Node]:
        if isinstance(self.host, SphinxDirective):
            return self.host.parse_text_to_nodes(text)
        elif isinstance(self.host, SphinxTransform):
            # TODO: dont create parser for every time
            if version_info[0] >= 9:
                parser = self.host.app.registry.create_source_parser(
                    'rst', env=self.host.env, config=self.host.config
                )
            else:
                parser = self.host.app.registry.create_source_parser(
                    self.host.app, 'rst'
                )
            settings = self.host.document.settings
            doc = new_document('<generated text>', settings=settings)
            parser.parse(text, doc)

            # NOTE: Nodes produced by standalone source parser should be fixed
            # before returning, cause they missed the processing by certain
            # Sphinx transforms.
            self._fix_document(doc)

            return doc.children
        else:
            assert False

    def _render_inline(self, text: str) -> tuple[list[Node], list[system_message]]:
        if isinstance(self.host, SphinxDirective):
            return self.host.parse_inline(text)
        if isinstance(self.host, SphinxRole):
            inliner = self.host.inliner
            memo = Struct(
                document=inliner.document,
                reporter=inliner.reporter,
                language=inliner.language,
            )

            return inliner.parse(text, self.host.lineno, memo, inliner.parent)
        elif isinstance(self.host, SphinxTransform):
            # Fallback to normal non-inline render then extract inline
            # elements by self.
            # FIXME: error seems be ignored?
            ns = self._render(text)
            if ns and isinstance(ns[0], nodes.paragraph):
                ns = ns[0].children
            return ns, []
        else:
            assert False

    def _fix_document(self, document: nodes.document) -> None:
        assert isinstance(self.host, SphinxTransform)

        """For documents generated by a separate source parser, some preprocessing
        may be missing. For example:

        - the lack of an ImageCollector result in an incorrect "node['uri']" and
          a missing "node['candidates']" :class:`nodes.images

        .. note::

           Since this depends on Sphinx's internal implementation, there may be
           many cases that have not been considered. We can only do our best
           and fix each error we encounter as possible.
        """

        ImageCollector().process_doc(self.host.app, document)

    def _fix_image_candidates(self, node: nodes.image) -> None:
        """This is another way for fixing images node instead of calling
        ImageCollector().process_doc. Keep it for now.
        """
        assert isinstance(self.host, SphinxTransform)

        # NOTE:
        # :meth:`sphinx.environment.collectors.ImageCollector.process_doc` add
        # a 'candidates' key to nodes.image, and subclasses of
        # :class:`sphinx.transforms.post_transforms.BaseImageConverter` require
        # the key.
        node['candidates'] = {}

        # Update `node['uri']` to a relative path from srcdir.
        node['uri'], _ = self.host.env.relfn2path(node['uri'])
